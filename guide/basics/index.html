<!DOCTYPE html>

<html lang="en-US">
	<head>
		<meta charset="UTF-8" />
		<title>Temple Basics ~ Temple | A JavaScript View Framework by Beneath the Ink</title>
		<!--[if lt IE 9]><script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
		
		<link rel="stylesheet" href="/temple/css/main.css" type="text/css" />

		<script type="text/javascript" src="/temple/js/jquery.min.js"></script>
		<script type="text/javascript" src="/temple/js/bootstrap.min.js"></script>
		<script type="text/javascript" src="/temple/js/ace-editor/ace.js"></script>
		<script type="text/javascript" src="/temple/js/temple.min.js"></script>
		<script type="text/javascript">var BASEURL = "/temple";</script>
		<script type="text/javascript" src="/temple/js/sandbox.js"></script>
	</head>
	<body class="page page-subnav">
		<nav class="navbar navbar-static-top navbar-inverse" id="top">
			<div class="container">
				<div class="navbar-header">
					<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#primary-nav">
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</button>
					<a class="navbar-brand" href="/temple/"><i class="icon icon-bank"></i> Temple <small>By Beneath the Ink</small></a>
				</div>

				<div class="collapse navbar-collapse" id="primary-nav">
					<ul class="nav navbar-nav navbar-right">
						<li><a href="/temple/guide">Guide</a></li>
						<li><a href="/temple/docs">Docs</a></li>
						<li><a href="https://github.com/BeneathTheInk/Temple">Github</a></li>
					</ul>
				</div>
			</div>
		</nav>

		
<main><section>
	<div class="container">
		<div class="row">
			<div class="col-lg-3">
				<div class="sidebar">
					<ul class="nav">
						
						
						<li>
							<a href="/temple/guide">Why Temple?</a>
							
						</li>
						
						
						<li>
							<a href="/temple/guide/install">Install</a>
							
						</li>
						
						
						<li class="active">
							<a href="/temple/guide/basics">Temple Basics</a>
							
						</li>
						
						
						<li>
							<a href="/temple/guide/interactivity">Interactivity &amp; Dynamic UIs</a>
							
						</li>
						
						
						<li>
							<a href="/temple/guide/reactive">Thinking Reactive</a>
							
						</li>
						
					</ul>
					<a href="#top" class="backtotop">Back to Top</a>
				</div>
			</div>
			<div class="col-lg-9 content">
			<h1 id="temple-basics">Temple Basics</h1><p>Temple is organized into a set of core JavaScript classes, called <em>bindings</em>, that either thinly wrap DOM nodes or provide interface control flow. Instances of these classes can be arranged in a tree much like the DOM itself, producing encapsulated components that can be modified directly in real time.</p>
<p>To begin, let&#39;s display a simple message to the user.</p>
<blockquote>
<p><strong>Note:</strong><br>The examples below live in an interactive JavaScript playground powered by Temple itself. Edit the code and click &quot;run&quot; to see a live result on the right.</p>
</blockquote>
<script type="text/plain" data-sandbox data-height="100">bmV3IFRlbXBsZS5UZXh0KCJIZWxsbyBXb3JsZCIpLnBhaW50KCJib2R5Iik7</script><p>In this example, we are creating a new text binding and setting it&#39;s value to <code>&quot;Hello World&quot;</code>. The <code>paint()</code> method takes the underlying DOM text node and appends it to the body. Try changing the message value and watch it update on the right.</p>
<p>A text binding&#39;s value can be changed immediately on screen with the <code>setValue()</code> method. This makes the interface very efficient since no extra bindings or DOM nodes need to be created.</p>
<script type="text/plain" data-sandbox data-height="100">dmFyIG1zZyA9IG5ldyBUZW1wbGUuVGV4dCgpLnBhaW50KCJib2R5Iik7Cm1zZy5zZXRWYWx1ZSgiSGVsbG8gV29ybGQiKTs=</script><p>Temple includes another important DOM binding: the element binding. Just like text bindings, these bindings thinly wrap a single DOM element. Temple has many common elements quickly accessible through the <code>Temple.DOM</code> object, or you can use the more generic <code>Temple.Element</code> to produce elements with any tag name. </p>
<p>Let&#39;s take our previous example, but render it in an <code>h1</code> tag instead. You may notice the <code>style()</code> method in the example below. This is just one of several vanity methods that help with common element tasks, such as adding classes and event listeners. Dealing directly with the underlying DOM node is also allowed and encouraged.</p>
<script type="text/plain" data-sandbox data-height="150">dmFyIGhlYWRlciA9IG5ldyBUZW1wbGUuRE9NLmgxKCJIZWxsbyBXb3JsZCIpOwoKaGVhZGVyLnN0eWxlKHsKICAgIGNvbG9yOiAicmVkIiwKICAgICJ0ZXh0LWFsaWduIjogImNlbnRlciIKfSk7CgpoZWFkZXIucGFpbnQoImJvZHkiKTs=</script><p>Bindings are meant to be nested, just like the real DOM. All bindings share a core set of methods that allow them to fit together in any configuration. In the above example, the string <code>&quot;Hello World&quot;</code> is being converted into a text binding and is appended to the <code>h1</code> binding as a child. Of course, that <code>h1</code> binding could also accept other element nodes or text nodes as children, too.</p>
<p>Dealing with children bindings works similarly to how the real DOM deals with children nodes. Children bindings are accessible via the <code>children</code> array property on all bindings. There&#39;s also a few helper properties for accessing specific children, such as <code>firstChild</code> and <code>nextSibling</code>. Remember, the order of children bindings is important because it ultimately decides the order of the resulting DOM nodes.</p>
<p>Let&#39;s take a slightly more complex example where we nest several elements and text nodes together.</p>
<script type="text/plain" data-sandbox data-height="200">bmV3IFRlbXBsZS5ET00uZGl2KCkuYXBwZW5kKAogICAgbmV3IFRlbXBsZS5ET00uaDEoIkhlYWRpbmciKSwKICAgIG5ldyBUZW1wbGUuRE9NLnAoKS5hcHBlbmQoCiAgICAgICAgIkV0aWFtIHBvcnRhIHNlbSAiLAogICAgICAgIG5ldyBUZW1wbGUuRE9NLmkoIm1hbGVzdWFkYSIpLAogICAgICAgICIgbWFnbmEgbW9sbGlzIGV1aXNtb2QuIgogICAgKQopLnBhaW50KCJib2R5Iik7</script><p>Here you&#39;ll notice the children are not being added via the constructor, but instead via <code>append()</code>. All bindings have the equivalent DOM methods <code>appendChild()</code> and <code>insertBefore()</code> for inserting children. <code>append()</code> uses these methods to append several elements at once. Children can be easily removed from their parent, too. Use the <code>removeChild()</code> method to remove a specific child or remove all of a binding&#39;s children with <code>empty()</code>.</p>
<p>When creating even moderately sized interfaces, having to write lots <code>new Temple.DOM</code> can be very time consuming. Temple comes equipped with a few helper methods that makes it easy to convert common DOM formats into bindings. We recommend assigning these to a smaller variable to make them very effective tools for generating interface markup.</p>
<script type="text/plain" data-sandbox data-height="250">Ly8gYSBzdHJpbmcgb2YgSFRNTApUZW1wbGUuZnJvbUhUTUwoJzxoMSBjbGFzcz0iaGVhZGVyIj5IZWxsbyBXb3JsZDwvaDE+JykucGFpbnQoImJvZHkiKTsKCi8vIGEgY3NzIHNlbGVjdG9yClRlbXBsZS5mcm9tU2VsZWN0b3IoImgxLmhlYWRlciIsICJIZWxsbyBXb3JsZCIpLnBhaW50KCJib2R5Iik7CgovLyBhIHNpbmdsZSBET00gZWxlbWVudApUZW1wbGUuZnJvbU5vZGUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaDEiKSkKICAgIC5hZGRDbGFzcygiaGVhZGVyIikKICAgIC5hcHBlbmQoIkhlbGxvIFdvcmxkIikKICAgIC5wYWludCgiYm9keSIpOw==</script><p>In the <a href="/temple/guide/interactivity">next section</a> we&#39;ll use the concepts taught here as a foundation for making interfaces dynamic and interactive in Temple.</p>

			</div>
		</div>
	</div>
</section></main>

<script type="text/javascript">
(function() {
	var el, top, bottom, bodyHeight, winHeight, state,
		updateState, updateSize, win;

	win = $(window);
	win.ready(function() {
		el = $(".sidebar");
		updateSize();
		win.resize(debounce(updateSize, 100)).scroll(updateState);
	});

	updateSize = function() {
		top = el.offset().top - 30;
		bottom = $("#footer").outerHeight(true);
		bodyHeight = document.body.offsetHeight;
		winHeight = window.innerHeight;
		updateState();
	}

	updateState = throttle(function() {
		var y = document.body.scrollTop,
			newState = inTop(y) ? "top" : inBottom(y) ? "bottom" : "middle";

		if (state === newState) {
			if (newState === "bottom") el.css("bottom", bottomOffset(y));
			return;
		}

		el.removeClass("affix affix-top affix-bottom");
		el.css({ bottom: "" });

		switch(newState) {
			case "top":
				el.addClass("affix-top");
				break;

			case "middle":
				el.addClass("affix");
				break;

			case "bottom":
				el.addClass("affix-bottom").css("bottom", bottomOffset(y));
				break;
		}

		if (state === "top") el.prop("scrollTop", 0);

		state = newState;
	}, 50);

	function inTop(y) {
		return y < top;
	}

	function inBottom(y) {
		return y + winHeight >= bodyHeight - bottom;
	}

	function bottomOffset(y) {
		return winHeight - (bodyHeight - y - bottom);
	}

	function debounce(func, wait, immediate) {
		var timeout, args, context, timestamp, result;

		var later = function() {
			var last = Date.now() - timestamp;

			if (last < wait && last > 0) {
				timeout = setTimeout(later, wait - last);
			} else {
				timeout = null;
				if (!immediate) {
					result = func.apply(context, args);
					if (!timeout) context = args = null;
				}
			}
		};

		return function() {
			context = this;
			args = arguments;
			timestamp = Date.now();
			var callNow = immediate && !timeout;
			if (!timeout) timeout = setTimeout(later, wait);
			if (callNow) {
				result = func.apply(context, args);
				context = args = null;
			}

			return result;
		};
	}

	function throttle(func, wait, options) {
		var context, args, result;
		var timeout = null;
		var previous = 0;
		if (!options) options = {};
		var later = function() {
			previous = options.leading === false ? 0 : Date.now();
			timeout = null;
			result = func.apply(context, args);
			if (!timeout) context = args = null;
		};
		return function() {
			var now = Date.now();
			if (!previous && options.leading === false) previous = now;
			var remaining = wait - (now - previous);
			context = this;
			args = arguments;
			if (remaining <= 0 || remaining > wait) {
				clearTimeout(timeout);
				timeout = null;
				previous = now;
				result = func.apply(context, args);
				if (!timeout) context = args = null;
			} else if (!timeout && options.trailing !== false) {
				timeout = setTimeout(later, remaining);
			}
			return result;
		};
	}
}).call(this);
</script>


		<div id="footer">
			<div class="container centered">
				<p>
					<a href="https://github.com/BeneathTheInk/Temple">Github</a> &bullet;
					<a href="https://github.com/BeneathTheInk/Temple/issues">Issues</a> &bullet;
					<a href="https://github.com/BeneathTheInk/Temple/releases">Releases</a>
				</p>
				<p>
					Created &amp; maintained by <a href="http://github.com/tyler-johnson">Tyler Johnson</a>. Licensed under <a href="http://opensource.org/licenses/MIT" rel="nofollow">MIT</a>.
					<span class="copyright">&copy; 2014 <a href="http://beneaththeink.com">Beneath the Ink, Inc.</a></span>
				</p>
			</div>
		</div>
	</body>
</html>