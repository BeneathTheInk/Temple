{
	var _ = require("underscore"),
		NODE_TYPE = require("./types"),
		Mustache = require("./");

	options = _.defaults(options || {}, {
		strict: true
	});
}

start = ws nodes:((scriptNode / elementNode) ws)* {
	var comps = _.pluck(nodes, 0).map(function(node) {
		if (node.type === NODE_TYPE.ELEMENT) {
			node.type = NODE_TYPE.VIEW;
		}

		return node;
	});

	if (comps.length === 1) {
		comps[0].version = Mustache.version;
		return comps[0];
	} else {
		return {
			type: NODE_TYPE.ROOT,
			version: Mustache.VERSION,
			views: comps
		};
	}
}

/*
HTML
*/
html = nodes:
	( section
	/ commentStache
	/ partialStache
	/ doubleStache
	/ tripleStache
	/ commentNode
	/ scriptNode
	/ elementNode
	/ textNode )* { return _.compact(nodes); }

// Text Node
textNode
	= text:[^<{]+ { return { type: NODE_TYPE.TEXT, value: text.join("") }; }

// Comment Nodes
commentNode
	= "<!--" v:$(!"-->" .)* "-->" {
		return { type: NODE_TYPE.XCOMMENT, value: v };
	}

scriptNode
	= "<" ws "script" attributes:(attribute)* ">" v:$(!"</script>" .)* "</script>" {
		return {
			type: NODE_TYPE.SCRIPT,
			value: v,
			attributes: attributes
		};
	}

// Element Nodes
elementNode
	= start:elementSelfClosed
	/ start:elementStart nodes:html end:elementEnd {
		if (start.name !== end) {
			throw new Error("Element tag mismatch: " + start.name + " !== " + end);
		}

		start.type = NODE_TYPE.ELEMENT;
		start.children = nodes;
		return start;
	}

elementSelfClosed
	= "<" tagname:key attributes:(attribute)* "/>" {
		return {
			name: tagname.toLowerCase(),
			type: NODE_TYPE.ELEMENT,
			attributes: attributes,
			children: []
		}
	}

elementStart
	= "<" tagname:key attributes:(attribute)* ">" {
		return { name: tagname.toLowerCase(), attributes: attributes };
	}

elementEnd
	= "</" tagname:key ">" { return tagname; }

// Element Attribute
attribute
	= key:key value:("=" ws string ws)? {
		value = value != null ? value[2] : null;
		var args;

		if (value != null) {
			// could fail on complex attributes
			try {
				args = parse(value,  _.extend({}, options, { startRule: "attrArguments" }));
			} catch(e) {
				args = [{ type: NODE_TYPE.LITERAL, value: value }];
			}
		} else {
			args = [];
		}

		return {
			type: NODE_TYPE.ATTRIBUTE,
			name: key,
			value: value,
			children: value != null ? parse(value, _.extend({}, options, { startRule: "attrValue" })) : [],
			arguments: args
		}
	}

attrValue = nodes:
	( section
	/ commentStache
	/ partialStache
	/ doubleStache
	/ tripleStache
	/ textNode )* { return _.compact(nodes); }

attrArguments =
	l:attrArg r:("," attrArg)* { return [].concat(l, _.pluck(r, 1)); }

attrArg = ws val:
	( stache
	/ string
	/ boolean
	/ number
	/ null
	/ undefined
	/ v:$(!"," .)* { return v.trim(); } ) ws {
		if (val != null && val.type) return val;
		return { type: NODE_TYPE.LITERAL, value: val };
	}

// mustache section
section
	= start:sectionStart nodes:html end:sectionEnd {
		if (options.strict && !_.isEqual(start.value.raw, end)) {
			throw new Error("Section tag mismatch: " + start.value.raw + " !== " + end);
		}

		start.value = start.value.result;
		start.children = nodes;
		return start;
	}

sectionStart
	= "{{" type:[#\^] value:pathQueryWithRaw "}}" {
		return {
			type: NODE_TYPE[type === "#" ? "SECTION" : "INVERTED"],
			value: value
		}
	}

sectionEnd
	= "{{/" value:(escape / [^}])* "}}" { return value.join(""); }

// Mustache staches without the prefixes
stache
	= value:("{{{" pathQuery "}}}" / "{{" pathQuery "}}") {
		return {
			type: NODE_TYPE.INTERPOLATOR,
			value: value[1]
		}
	}

// Mustache double stache
doubleStache
	= "{{" ![/#{!$>\^] m:"&"? value:pathQuery "}}" {
		return {
			type: m ? NODE_TYPE.TRIPLE : NODE_TYPE.INTERPOLATOR,
			value: value
		}
	}

// Mustache triple stache
tripleStache
	= "{{{" value:pathQuery "}}}" {
		return {
			type: NODE_TYPE.TRIPLE,
			value: value
		}
	}

commentStache
	= "{{!" value:(escape / [^}])* "}}" {
		return {
			type: NODE_TYPE.MCOMMENT,
			value: value.join("").trim()
		}
	}

partialStache
	=  "{{" m:[$>] value:(escape / [^}])* "}}" {
		return {
			type: NODE_TYPE.PARTIAL,
			value: value.join("").trim(),
			local: m === "$"
		}
	}

/*
Paths
*/
pathQuery = l:path r:("|" path)* { return [].concat(l, _.pluck(r, 1)); }

pathQueryWithRaw = m:pathQuery { return { raw: text(), result: m } }

path
	= ws p:pathPrefix? c:pathCore ws {
		if (p == null) p = { type: "all" };
		p.parts = c;
		return p;
	}
	/ ws p:pathPrefix ws { p.parts = []; return p; }

pathPrefix
	= d:"../"+ { return { type: "parent", distance: d.length }; }
	/ "./" { return { type: "local" }; }
	/ "." { return { type: "local" }; }
	/ "/" { return { type: "root" }; }

pathCore = l:pathPart r:("." pathPart)* { return [].concat(l, _.pluck(r, 1)); }

pathPart = k:$([a-z0-9$_]i [a-z0-9:\-_$]i*) c:pathDynamic* { return { key: k, children: c } }

pathDynamic = "[" ws c:(integer / string / path) ws "]" { return c; }

/*
Literals
*/
boolean
	= "true" { return true; }
	/ "false" { return false; }

number = "-"? [0-9]+ ("." [0-9]+)? { return parseFloat(text(), 10); }

integer = [0-9]+ { return parseInt(text(), 10); }

string
	= "\"" v:(escape / [^"])* "\"" { return v.join(""); }
	/ "'" v:(escape / [^'])* "'" { return v.join(""); }

null = "null" { return null; }
undefined = ("undefined" / "void" gws (![,; \t\n\r] .)+) { return void 0; }

/*
Utils
*/
key = ws k:$[a-z0-9_-]i+ ws { return k; }

ws "whitespace" = $[ \t\n\r]*
gws "guaranteed whitespace" = $[ \t\n\r]+

escape = "\\" char:. { return char; }
