{
	var ast = require("./ast");
	var object = require("lodash/array/object");
	var assign = require("lodash/object/assign");
	var pluck = require("lodash/collection/pluck");
	var contains = require("lodash/collection/contains");
	var jsep = require("jsep");

	options = assign({
		strict: true
	}, options);

	function createNode(type, props) {
		var loc = location();
		return new ast[type](loc.start.line, loc.start.column, props);
	}

	function combineText(nodes, type) {
		return nodes.reduce(function(m, n) {
			var last = m.length - 1;
			if (typeof n === "string" && typeof m[last] === "string") {
				m[last] += n;
			} else {
				m.push(n);
			}
			return m;
		}, []).map(function(n) {
			if (typeof n !== "string") return n;
			return createNode(type || "Text", { value: n });
		});
	}

	function combine(nodes, type) {
		return ast.SectionTag.convert(combineText(nodes, type));
	}

	function createExpression(v) {
		return createNode("Expression", {
			value: v,
			tree: jsep(v)
		});
	}
}

start = ws nodes:(
	( scriptNode
	/ templateNode
	/ commentNode ) ws)* {
		return createNode("Root", {
			children: pluck(nodes, 0)
		});
	}

/*
Templates
*/
templateNode
	= "<" ws "template" attrs:attributes ">" nodes:html "</template>" {
		var name;

		attrs.forEach(function(a) {
			if (a.name === "name") name = a.value;
		});

		return createNode("Template", {
			name: name,
			children: nodes
		});
	}

/*
Interpolator
*/
variable = value:
	( "{{{" v:$(!"}}}" .)* "}}}" { return v; }
	/ "{{"  v:$(!"}}"  .)* "}}"  { return v; } ) {
		return createExpression(value);
	}

interpolator = expression:variable {
		return createNode("Interpolator", {
			expression: expression
		});
	}

/*
HTML
*/
html = nodes:
	( section
	/ interpolator
	/ commentNode
	/ elementNode
	/ notClosingTag )* { return combine(nodes); }

tagname = ws k:$[a-z0-9\-$]i+ ws { return k.toLowerCase(); }

notClosingTag = $(!("</" tagname ">") !"{%" !"{{" .)

// Comment Nodes
commentNode = value:
	( "<!--" v:$(!"-->" .)* "-->" { return v; }
	/ "{#" v:$(!"#}" .)* "#}" { return v; }) {
		return createNode("Comment", { value: value });
	}

// script elements
scriptNode
	= "<" ws "script" attrs:(attribute)* ">" v:$(!"</script>" .)* "</script>" {
		return createNode("Script", {
			attributes: attrs,
			value: v
		});
	}
	/ "<" ws "$script" attrs:(attribute)* ">" v:$(!"</$script>" .)* "</$script>" {
		return createNode("Script", {
			attributes: attrs,
			value: v
		});
	}

// Element Nodes
elementNode
	= "<" tagname:tagname attrs:attributes "/>" {
		return createNode("Element", {
			tagname: tagname,
			attributes: attrs,
			children: []
		});
	}
	/ "<" starttag:tagname attrs:attributes ">" nodes:html "</" endtag:tagname ">" {
		starttag = starttag;
		endtag = endtag;

		if (starttag !== endtag) {
			throw new Error("Element tag mismatch: " + starttag + " !== " + endtag);
		}

		return createNode("Element", {
			tagname: starttag,
			attributes: attrs,
			children: nodes
		});
	}

/*
Attributes
*/
attributes = (attribute)*

// Element Attribute
attribute
	= key:attributeName value:("=" ws attributeValue ws)? {
		value = value != null ? value[2] : void 0;
		return createNode("Attribute", assign({
			name: key
		}, value));
	}

attributeName = ws k:$[a-z0-9\-$]i+ ws { return k.toLowerCase(); }

attributeValue =
	nodes:( "\"" n:
		( section
		/ variable
		/ escape
		/ $(!"\"" !"{%" !"{{" .))* "\"" { return combine(n, "Literal"); }
	/ "'" n:
		( section
		/ variable
		/ escape
		/ $(!"'" !"{%" !"{{" .))* "'" { return combine(n, "Literal"); }
	) {
		var t = text();
		t = t.substr(1, t.length - 2);
		// var args;

		// try {
		// 	args = peg$parse(t, { startRule: "arguments" });
		// } catch(e) {
		// 	args = [];
		// }

		return {
			children: nodes,
			// arguments: args,
			value: t
		};
	}

arguments = ws l:argument ws r:("," ws argument ws)* {
	return combine([l].concat(pluck(r, 2)), "Literal");
}

argument =
	  variable
	/ string
	/ number
	/ boolean
	/ null
	/ undefined
	/ $(!"," .)+

/*
Sections
*/
section
	= "{%" ws k:sectionName ws "%}" {
		if (typeof k === "string") k = { name: k };
		return createNode("SectionTag", k);
	}

sectionName =
	"if"i ws v:$(sectionChar)* {
		return {
			name: "if",
			expression: createExpression(v)
		};
	}
	/ "else"i gws "if"i ws v:$(sectionChar)* {
		return {
			name: "else if",
			expression: createExpression(v)
		};
	}
	/ "else"i
	/ "endif"i
	/ "for"i ws v:$(sectionChar)* {
		return {
			name: "for",
			expression: createExpression(v)
		};
	}
	/ "endfor"i
	/ "render"i ws v:$(sectionChar)* {
		return {
			name: "render",
			expression: createExpression(v)
		};
	}
	/ "with"i ws v:$(sectionChar)* {
		return {
			name: "with",
			expression: createExpression(v)
		};
	}
	/ "endwith"i
	/ key:$[a-z0-9]i+ &{
		throw new Error("Unknown section key '" + key + "'");
	}

sectionChar = !"%}" .

/*
Literals
*/
boolean
	= "true" { return true; }
	/ "false" { return false; }

number = "-"? [0-9]+ ("." [0-9]+)? { return parseFloat(text(), 10); }

integer = [0-9]+ { return parseInt(text(), 10); }

string
	= "\"" v:(escape / [^"])* "\"" { return v.join(""); }
	/ "'" v:(escape / [^'])* "'" { return v.join(""); }

null = "null" { return null; }
undefined = ("undefined" / "void" gws (![,; \t\n\r] .)+) { return void 0; }

/*
Utils
*/
ws "whitespace" = $[ \t\n\r]*
gws "guaranteed whitespace" = $[ \t\n\r]+

escape = "\\" char:. { return char; }
