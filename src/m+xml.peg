{
	var ast = require("./ast");
	var object = require("lodash/array/object");
	var assign = require("lodash/object/assign");
	var pluck = require("lodash/collection/pluck");
	var contains = require("lodash/collection/contains");
	var jsep = require("jsep");

	options = assign({
		strict: true
	}, options);

	function createNode(type, props) {
		var loc = location();
		return new ast[type](loc.start.line, loc.start.column, props);
	}

	function combineText(nodes) {
		return nodes.reduce(function(m, n) {
			var last = m.length - 1;
			if (typeof n === "string" && typeof m[last] === "string") {
				m[last] += n;
			} else {
				m.push(n);
			}
			return m;
		}, []).map(function(n) {
			if (typeof n !== "string") return n;
			return createNode("Text", { value: n });
		});
	}

	function combine(nodes) {
		return ast.SectionTag.convert(combineText(nodes));
	}
}

start = ws nodes:(
	( scriptNode
	/ templateNode
	/ commentNode ) ws)* {
		return createNode("Root", {
			children: pluck(nodes, 0)
		});
	}

/*
Templates
*/
templateNode
	= "<" ws "template" attrs:attributes ">" nodes:templateRootNodes "</template>" {
		var name, _extends;

		attrs.forEach(function(a) {
			if (a.name === "name") name = a.value;
			else if (a.name === "extends") _extends = a.value;
		});

		return createNode("Template", {
			name: name,
			extends: _extends,
			children: nodes
		});
	}

templateRootNodes = nodes:
	( section
	/ interpolator
	/ commentNode
	/ scriptNode
	/ elementNode
	/ notClosingTag )* { return combine(nodes); }

/*
HTML
*/
html = nodes:
	( section
	/ interpolator
	/ commentNode
	/ elementNode
	/ notClosingTag )* { return combine(nodes); }

tagname = ws k:$[a-z0-9\-$]i+ ws { return k.toUpperCase(); }

notClosingTag = $(!("</" tagname ">") !"{%" !"{{" .)

// Comment Nodes
commentNode = value:
	( "<!--" v:$(!"-->" .)* "-->" { return v; }
	/ "{#" v:$(!"#}" .)* "#}" { return v; }) {
		return createNode("Comment", { value: value });
	}

// script elements
scriptNode
	= "<" ws "script" attrs:(attribute)* ">" v:$(!"</script>" .)* "</script>" {
		return createNode("Script", {
			attributes: attrs,
			value: v
		});
	}
	/ "<" ws "$script" attrs:(attribute)* ">" v:$(!"</$script>" .)* "</$script>" {
		return createNode("Script", {
			attributes: attrs,
			value: v
		});
	}

// Element Nodes
elementNode
	= "<" tagname:tagname attrs:attributes "/>" {
		return createNode("Element", {
			tagname: tagname,
			attributes: attrs,
			children: []
		});
	}
	/ "<" starttag:tagname attrs:attributes ">" nodes:html "</" endtag:tagname ">" {
		starttag = starttag;
		endtag = endtag;

		if (starttag !== endtag) {
			throw new Error("Element tag mismatch: " + starttag + " !== " + endtag);
		}

		return createNode("Element", {
			tagname: starttag,
			attributes: attrs,
			children: nodes
		});
	}

/*
Attributes
*/
attributes = (attribute)*

// Element Attribute
attribute
	= key:attributeName value:("=" ws attributeValue ws)? {
		value = value != null ? value[2] : void 0;
		return createNode("Attribute", assign({
			name: key
		}, value));
	}

attributeName = ws k:$[a-z0-9\-$]i+ ws { return k.toLowerCase(); }

attributeValue =
	nodes:( "\"" n:
		( section
		/ interpolator
		/ escape
		/ $(!"\"" !"{%" !"{{" .))* "\"" { return combine(n); }
	/ "'" n:
		( section
		/ interpolator
		/ escape
		/ $(!"'" !"{%" !"{{" .))* "'" { return combine(n); }
	) {
		var t = text();
		t = t.substr(1, t.length - 2);
		var args;

		try {
			args = peg$parse(t, { startRule: "arguments" });
		} catch(e) {
			args = [];
		}

		return {
			children: nodes,
			arguments: args,
			value: t
		};
	}

arguments = ws l:argument ws r:("," ws argument ws)* {
	return [l].concat(pluck(r, 2));
}

argument = nodes:
	( section
	/ interpolator
	/ string
	/ number
	/ boolean
	/ null
	/ undefined
	/ $(!"," .))* {
		return combine(nodes);
	}

/*
Sections
*/
section
	= "{%" ws k:sectionName ws "%}" {
		if (typeof k === "string") k = { name: k };
		return createNode("SectionTag", k);
	}

sectionName =
	"if"i ws v:$(sectionChar)* {
		return {
			name: "if",
			expression: createNode("Expression", {
				value: v,
				tree: jsep(v)
			})
		};
	}
	/ "else"i gws "if"i ws v:$(sectionChar)* {
		return {
			name: "else if",
			expression: createNode("Expression", {
				value: v,
				tree: jsep(v)
			})
		};
	}
	/ "else"i
	/ "endif"i
	/ "for"i ws v:$(sectionChar)* {
		return {
			name: "for",
			expression: createNode("Expression", {
				value: v,
				tree: jsep(v)
			})
		};
	}
	/ "endfor"i
	/ "render"i ws v:$(sectionChar)* {
		return {
			name: "render",
			expression: createNode("Expression", {
				value: v,
				tree: jsep(v)
			})
		};
	}
	/ "with"i ws v:$(sectionChar)* {
		return {
			name: "with",
			expression: createNode("Expression", {
				value: v,
				tree: jsep(v)
			})
		};
	}
	/ "endwith"i
	/ key:$[a-z0-9]i+ &{
		throw new Error("Unknown section key '" + key + "'");
	}

sectionChar = !"%}" .

jsvariable = $[a-z0-9$_]i*

/*
Interpolator
*/
interpolator = value:
	( "{{{" v:$(!"}}}" .)* "}}}" { return v; }
	/ "{{"  v:$(!"}}"  .)* "}}"  { return v; }  ) {
		return createNode("Interpolator", {
			expression: createNode("Expression", {
				value: value,
				tree: jsep(value)
			})
		});
	}

/*
Literals
*/
boolean
	= "true" { return true; }
	/ "false" { return false; }

number = "-"? [0-9]+ ("." [0-9]+)? { return parseFloat(text(), 10); }

integer = [0-9]+ { return parseInt(text(), 10); }

string
	= "\"" v:(escape / [^"])* "\"" { return v.join(""); }
	/ "'" v:(escape / [^'])* "'" { return v.join(""); }

null = "null" { return null; }
undefined = ("undefined" / "void" gws (![,; \t\n\r] .)+) { return void 0; }

/*
Utils
*/
ws "whitespace" = $[ \t\n\r]*
gws "guaranteed whitespace" = $[ \t\n\r]+

escape = "\\" char:. { return char; }
